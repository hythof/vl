__compile_to_c src =
  c <- compile(src)
  `#include <stdio.h>

` . c . `

int main() {
  printf(v_ret[0] == 'i' ? "%d" : "%g", v_main());
  return 0;
}
`


enum ast:
  int value int
  float value float
  op2 op op, left ast, right ast, type type
  func args []tv, body ast, type type
  call name string, argv []ast, type type

enum op:
  add, sub, mul, div

struct kv:
  key string
  val ast

struct tv:
  name string
  type type

enum type:
  untyped
  int
  float

compile src =
  defines <- parse(src).infer_env
  h <- defines.map(x => x.to_h)
  c <- defines.map(x => x.to_c)
  alias_main = "#define v_main _v_main"
  type_ret = `const char v_ret[] = "` . defines.find(x => x.key == "main").val.v_type . `";`
  extras = [alias_main type_ret]
  (h ++ extras ++ c).join("\n")

parse src = parser.parse_top(src)

to_h x = x.val.v_type . " _v_" . x.key . "();"
to_c x = x.val.v_type . " _v_" . x.key . "() { return " . x.val.to_exp . "; }"

infer_env env = env.map(x => kv(x.key x.val.infer_ast(env)))
infer_ast x env =
| ast.int _ = x
| ast.float _ = x
| ast.op2 _ = ast.op2(x.op x.left x.right infer_type(x.left env))
| ast.func _ = ast.func(x.args x.body infer_type(x.body env))
| ast.call _ = ast.call(x.name x.argv infer_type(env.find(y => y.key == x.name) env))
infer_type x env =
| ast.int _ = type.int
| ast.float _ = type.float
| ast.op2 _ = x.left.infer_type(env)
| ast.func _ = x.body.infer_type(env)
| ast.call _ = env.find(y => y.key == x.name).val.infer_type(env)
v_type t =
| ast.int = "int"
| ast.float = "float"
| ast.op2 = t.type.c_type
| ast.func = t.type.c_type
| ast.call = t.type.c_type
c_type t =
| type.untyped = "void*"
| type.int = "int"
| type.float = "float"
to_exp node =
| ast.int = node.value.to_string
| ast.float = node.value.to_string
| ast.op2 = op2_to_c(node.op to_exp(node.left) to_exp(node.right))
| ast.func = to_exp(node.body)
| ast.call = "_v_" . node.name . "()"
op2_to_c op l r =
| op.add _ _ = l . " + " . r
| op.sub _ _ = l . " - " . r
| op.mul _ _ = l . " * " . r
| op.div _ _ = l . " / " . r



flow parser:
  eof
  miss reason string
  bug
  input string
  satisfy f =
    c <- input.at(0) | eof
    f(c) || miss
    input := input.slice(1)
    c
  parse_top =
    defs <- parse_def.sepby1(read_br)
    read_spaces
    (input.length == 0) || bug
    defs
  parse_def =
    name <- read_id
    args <- read_id.lex.many
    read_string("=").lex
    body <- parse_exp.lex
    kv(name ast.func(args body type.untyped))
  parse_call =
    name <- read_id
    argv <- between("(" ")" parse_exp.many) | []
    ast.call(name argv type.untyped)
  parse_exp = parse_op2.lex
  parse_op2 =
    left <- parse_call | parse_float | parse_int
    parse_op2_remaining(left) | left
  parse_op2_remaining left =
    op <- parse_op
    right <- parse_op2
    ast.op2(op left right type.untyped)
  parse_op =
    op_text <- read_one(["+" "-" "*" "/" "%" "**" "&&" "||" "++"])
    to_op(op_text)
  parse_float =
    n1 <- read_one(["0" "1" "2" "3" "4" "5" "6" "7" "8" "9"]).many1
    read_string(".")
    n2 <- read_one(["0" "1" "2" "3" "4" "5" "6" "7" "8" "9"]).many1
    n = (n1 ++ ["."] ++ n2).join("").to_float
    ast.float(n)
  parse_int =
    n <- read_one(["0" "1" "2" "3" "4" "5" "6" "7" "8" "9"]).many1.fmap(s => s.join("").to_int)
    ast.int(n)
  lex f =
    read_one([" " "\t"]).many
    f
  read_br =
    read_one([" " "\t"]).many
    read_one(["\r" "\n"])
  read_spaces = read_one([" " "\t" "\r" "\n"]).many
  read_string s = satisfy(x => x == s)
  read_one set = satisfy(x => set.has(x))
  read_id =
    x <- read_one(["_" "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z" "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s" "t" "u" "v" "w" "x" "y" "z"])
    xs <- read_one(["_" "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z" "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s" "t" "u" "v" "w" "x" "y" "z"]).many
    x . xs.join("")
many p = p.many_acc([])
many1 p =
  x <- p
  xs <- p.many
  [x] ++ xs
many_acc p acc = p.fmap(x => p.many_acc(acc ++ [x])) | acc
fmap p f =
  x <- p
  f(x)
between l r c =
  l
  x <- c
  r
  x
sepby p s = sepby1(p s) | []
sepby1 p s =
  x <- p
  xs <- many(combine(s p))
  [x] ++ xs
combine aa bb =
  aa
  bb
to_op op_text =
| "+" = op.add
| "-" = op.sub
| "*" = op.mul
| "/" = op.div



__comment__
enum type:
  untyped
  void
  s8, s16, s32, s64
  u8, u16, u32, u64
  f32, f64
  string
  cint, cfloat, cstring
  struct name string, fields []tv
  list generic type
  dict key type, val type
  func args []tv, ret type
  exception name string, extra ast
  try type type
enum ast:
  int value int
  float value float
  op2 op op, left ast, right ast, type type
  call ref string, args []ast, type type
  def name string, args []arg, lines []ast, type type
  decl name string, args []args, targs []args, type type
enum op:
  add, sub, mul, div, mod, pow
  and, or
  append
