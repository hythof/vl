__compile_to_c src =
  defines <- compile(src)
  `#include <stdio.h>

` . defines . `

int main() {
  printf("%d", v_main());
  return 0;
}
`

enum ast:
  int value int
  float value float
  op2 op op, left ast, right ast, type type
  func args []tv, body ast
  call name string, argv []ast

enum op:
  add, sub, mul, div

struct tv:
  name string
  type type

enum type:
  untyped
  int, float
  cint, cfloat

struct define:
  funcs []defun
  types []detype
struct detype:
  name string
  fields []tv
struct defun:
  name string
  args []tv
  ret type
  body []ast

compile src =
  define <- parse(src).inferent.to_define
  h <- define.types.map(x => x.to_h)
  c <- define.funcs.map(x => x.to_c.to_string)
  (h ++ c).join("\n")
parse src = parser(src).parse_op2
inferent env = env
to_define env = define([defun("v_main" [] type.untyped [env])] [])
to_h t = ""
to_c x = "int " . x.name . "() { return " . x.body.at(0).to_exp.to_string . "; }"
to_exp node =
| ast.int = node.value
| ast.op2 = op2_to_c(node.op to_exp(node.left) to_exp(node.right))
op2_to_c op l r =
| op.add = l + r
| op.sub = l - r
| op.mul = l * r
| op.div = l / r



flow parser:
  eof
  miss reason string
  input string
  satisfy f =
    c <- input.at(0) | eof
    f(c) || miss
    input := input.slice(1)
    c
  parse_top = parse_def.many
  parse_def =
    name <- read_id
    args <- read_id.lex.many
    read_string("=").lex
    body <- parse_exp
    eol
    ast.func(name args body)
  parse_call =
    name <- read_id
    argv <- between("(" ")" parse_exp.many)
    ast.call(name argv)
  parse_exp = parse_call | parse_op2
  parse_op2 =
    left <- parse_int
    parse_op2_remaining(left) | left
  parse_op2_remaining left =
    op <- parse_op
    right <- parse_op2
    ast.op2(op left right)
  parse_op =
    op_text <- read_one(["+" "-" "*" "/" "%" "**" "&&" "||" "++"])
    to_op(op_text)
  parse_int =
    n <- read_one(["0" "1" "2" "3" "4" "5" "6" "7" "8" "9"]).many1.fmap(s => s.join("").to_int)
    ast.int(n)
  lex f =
    read_one(" \t").many
    f
  eol = read_one(["\r" "\n"]).lex | (input.length == 0 || miss)
  read_string s = satisfy(x => x == s)
  read_one set = satisfy(x => set.has(x))
  read_id =
    x <- read_one(["A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z" "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s" "t" "u" "v" "w" "x" "y" "z"])
    xs <- read_one(["0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z" "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s" "t" "u" "v" "w" "x" "y" "z"]).many
    x . xs
many p = p.many_acc([])
many1 p =
  x <- p
  xs <- p.many
  [x] ++ xs
many_acc p acc = p.fmap(a => p.many_acc(acc ++ [a])) | acc
fmap p f =
  x <- p
  f(x)
between l r c =
  l
  v <- c
  r
  v
sepby p s = sepby1(p s) | []
sepby1 p s =
  x <- p
  xs <- many(combine(s p))
  [x] ++ xs
combine a b =
  a
  b
to_op op_text =
| "+" = op.add
| "-" = op.sub
| "*" = op.mul
| "/" = op.div



__comment__
enum type:
  untyped
  void
  s8, s16, s32, s64
  u8, u16, u32, u64
  f32, f64
  string
  cint, cfloat, cstring
  struct name string, fields []tv
  list generic type
  dict key type, val type
  func args []tv, ret type
  exception name string, extra ast
  try type type
enum ast:
  int value int
  float value float
  op2 op op, left ast, right ast, type type
  call ref string, args []ast, type type
  def name string, args []arg, lines []ast, type type
  decl name string, args []args, targs []args, type type
enum op:
  add, sub, mul, div, mod, pow
  and, or
  append
