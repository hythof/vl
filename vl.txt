目的
言語を越えて利用できる汎用ライブラリを作るための言語を製作し、複数の
プロジェクトでそのメリットを享受する。
                                                           2010/12/12
---------------------------------------------------------------------

背景
=====================================================================
* 短い答え *
一度はオレオレ言語を作りたい。

* 長い答え*
CGIやMIME、SMTP、POPといったプロトコル処理のライブラリ、ORマッパや
HTMLテンプレート、WEBフレームワーク等がそれぞれの言語系で雨後の筍の
ように乱立している。それらは有用で役に立つ半面、無視できない学習コスト
やバージョン毎の非互換性に直面することも多々ある。また一部の実装は
便利だが遅い。そこでLL言語やC言語へのトランスレータとなる仮想的な言語
を作成することで、言語間の非互換性(Ruby1.9系とRuby1.8系など)を吸収し
必要に応じて高速化(C言語での実装)を切り替えられるようにしたい。

概要
=====================================================================
小さく  実装はRubyで1000ステップに収まるようにする(テストを除く)
単純    変換先はC言語, Ruby, JavaScript
力強い  少ない表記で多くの事を表現できる
便利    各種フック、ログ、テスト、などランタイムを開発者がいじれる

ディレクトリ構成
=====================================================================
vl.rb

クラスとインターフェース
=====================================================================
class VL
  class LA
    def initialize code
  class Base
    def initialize src
    def make outfile
    def run
  class C    < Base
  class Ruby < Base
  class PHP  < Base

実行例
=====================================================================
VL::C.new("foo.vl").make("a.out")
# or puts VL::C.new("foo.vl").run

必要なプラットフォーム
=====================================================================
Ruby 1.8

テスト計画
=====================================================================
[TBD]

障害からの復旧計画
=====================================================================
なし

セキュリティ考慮
=====================================================================
- メモリ破壊
  メモリ操作を全て隠蔽し、安全な部分だけ提供する

- ライブラリ(pure C)との連携
  扱う値がNullにならないよう言語を設計する。

既知の問題点
=====================================================================
既存ライブラリに優秀なものが多く置き換えを促せるか？(特にPerl/CPAN)。
機械的にトランスレートされたコードは言語らしさが失われる。
この言語自体の学習コストまたは開発コストも無視できない。

参考
=====================================================================
[TBD]

参考、ドキュメント履歴
=====================================================================
2010/05/05 初版






その他開発資料
=====================================================================
== Type ==
class  # { ... }
bit    # 0:2bit or 10bit
int    # 0      or Int
double # 0.0    or Double
string # "..."  or String
array  # [String] or [Int] or [Class]
dict   # [String=Int] or [""=0.0]
set    # <debug=1 error=2 fatal=9>
io     # read() write() open() close()

== GOTO ==
for    # (1..10).each {  }
while  # BOOL.each {}
if     # (BOOL) T={} F={}
case   # RET = TARGET & {
       #   A     : ...
       #   B,C   : ...
       #   0..10 : ...
       #   Z == Q: ...
       #   _     : ...
       # }

== Core ==
# implements of native language
File     < io
Socket   < io
Random   < io
Thread   < # pthread or fork?

== Library implements for vl ==
DateTime < int # UTC only?
Encode   < class # C(NKF? or iconv? or ICU?) or LL
Regexp   < class # C(oniguruma or ICU) or LL
TCP      < Socket
UDP      < Socket
(TCPClient|TCPServer) < TCP + Thread
(UDPClient|UDPServer) < UDP + Thread

========
Radius : {
  _dummy1       : 1bit # private
  _padding1     : 3bit # private
  code          : 1byte
  identifier    : 1byte
  length        : 2byte
  autehnticator : 16byte
  attr : [{
    type : 1byte : enum{
      accessRequest     : 1
      accessAccept      : 2
      accessReject      : 3
      accountingRequest : 4
      accountingResponse: 5
      accessChallenge   : 6
    }
    length: 1byte 
    value : 0..255byte : fook{
        =:number : length = 1
        =:byte   : length = value.byte.length
        =        : Error("bad value")
    }
    valid : type     == set{0..20 31 33 35..60}
            & length == value.byte.size
    +=:(type, value) : pass
    +=:(type, _)     : Error("bad value")
    +=:(_   , value) : Error("bad type")
    +=               : Error("bad type and value")
  }]
  valid : do{ attr.all(.valid()) }
}

r : Radius
r.attr += (.type.accessRequest, 10)

r : Radius.send_packet + {
  .username = "foobar"
  .password = "secret"
}
r.send()

--------------------------------------------------------
strict_radius = radius() # shallow copy
strict_radius.valid  = {
  # radius.Base.valid is original function and readonly.
  Base.valid & code == <1 .. 10>
}
loose_radius = radius() # shallow copy
strict_radius.valid  = T
# for c

int strict_radius.valid(void);
int T();
int T(){ return 1; }
========================================================

http = {
  CRLF    : "\r\n" # readonly
  Version : "1.1"  # readonly
  request : do {
    buf : IO.stdin.read()
    # ...
  }

  response : {
    status   : 200
    type     : "text/html"
    charset  : "utf-8"
    body     : ""
    headers  : [{key:"", val:""}] + {
      to_string : join(CRLF, map(key + ": " + val))
    }
    cookies  : array

    packet : do {
      sendfile ? body = IO.read(file)
      headers += {"Content-Length", body.size.string}
      headers += cookies.zip(prefix = "Set-Cookie")
      headers.to_string + CRLF + CRLF + body
    }
  }
}

http.response.headers += {key="sid", val="SID"}

request_handler = http + {
  in : http.request
  out: http.response
  render : out.body = IO.read(file:"")
  get    : render("index.html")
  post : {
    form = in.post() & input
    render(
      form.step & Choise(
        _ : "index.html"
        1 : "confirm.html"
        2 : "thanks.html"
      )
    )
  }
  level : Choise(
    _     : 1
    debug : 1
    info  : 2
    warn  : 3
    error : 4
  )

  head : {
    render("index.html")
  }

  callback : Choise(in.request_method
    "GET"  : get()
    "POST" : post()
    "HEAD" : head()
    _      : get()
  )
}

Choise = {
  x : X
  type: array(type=x)
  
}


p : Process + {
  server : do Net.TCP.listen + {
    ip           : Any
    port         : 80
    in_protocol  : http.request
    out_protocol : http.response
    _list        : [Process(request_handler)] * 4
    callback     : {
      _list.min(queue.size).push(
	in:in_protocol
	out:out_protocol)
    }
  }

  C.printf("%s age=%d", "foo", "bar")
  C.connect("%s age=%d", "foo", "bar")
  n = C.add(10, 20)
  0IO.puts(n)
  IO.puts(C.INET_ANY)
}
p.start

C.include += "mysql.h"
C.init += {

}


__C__
MYSQL mysql;
mysql = mysql_init(NULL);
if (NULL==mysql) {
  // 初期化失敗
}
const char *hostname = NULL;
const char *username = "user";
const char *password = "pass";
const char *database = "database-name";
unsigned long portnumber = 0;
if (NULL==mysql_real_connect(mysql, hostname, username, database, portnumber, NULL, 0) {
  // 接続エラー
   printf("error: %s\n", mysql_error(mysql));
} else {
  //  接続成功
}

int r;
r = mysql_query(mysql, "CREATE TABLE hoge (id integer)" );
if (r) {
   // 失敗
   printf("error: %s\n", mysql_error(mysql));
} else {
   // 成功
}
__C__

log = {
  io    = IO.stderr
  level = <debug info warn error>
  log   = io.puts(:String)
  debug = level >= level.debug & log
  info  = level >= level.info  & log
  warn  = level >= level.warn  & log
  error = level >= level.error & log
}
log.io = IO.stderr
log.level.debug
log.level.info








== Mini ==




== Core ==









== Type ==
class  # { ... }
bit    # 0:2bit or 10bit
int    # 0      or Int
double # 0.0    or Double
string # "..."  or String
array  # [String] or [Int] or [Class]
dict   # [String=Int] or [""=0.0]
set    # <debug=1 error=2 fatal=9>
io     # read() write() open() close()

== GOTO ==
for    # (1..10).each {  }
while  # BOOL.each {}
if     # (BOOL) T={} F={}
case   # RET = TARGET & {
       #   A     : ...
       #   B,C   : ...
       #   0..10 : ...
       #   Z == Q: ...
       #   _     : ...
       # }

== Core ==
# implements of native language
File     < io
Socket   < io
Random   < io
Thread   < # pthread or fork?

== Library implements for vl ==
DateTime < int # UTC only?
Encode   < class # C(NKF? or iconv? or ICU?) or LL
Regexp   < class # C(oniguruma or ICU) or LL
TCP      < Socket
UDP      < Socket
(TCPClient|TCPServer) < TCP + Thread
(UDPClient|UDPServer) < UDP + Thread

== C implements ==
-- atomic type --
string  : *char    # fixed string
int     : int
double  : double
object  : struct{} # fixed struct
array   : []       # fixed array

-- native library --
decimal : object
list    : object
table   : object

-- library type --
io       : object  # open/close/read/write/seek
socket   : io      # bsd socket wrapper
tcp      : socket  # bsd socket wrapper + utility function
udp      : socket  # bsd socket wrapper + utility function
file     : io      # file io
process  : object  # fork, msque
thread   : process # pthread, queue(original)
pack     : object  # MessagePack
event    : object  # libev
regexp   : object  # oniguruma
yaml     : object  # libyaml-c
xml      : object  # libxml2
encode   : object  # iconv, nkf?
logger   : object  # syslog
ssl      : object  # openssl
deflate  : object  # zip, bzip, gzip, tar
digest   : object  # md5, sha256, sha512, sha 762, sha1024, hmac

-- archive library --
tcp protocol : tcp
udp protocol : udp
shell    : object
http     : tcp protocol
smtp     : tcp protocol
pop      : tcp protocol
imap     : tcp protocol
telnet   : tcp protocol
mime     : object
cgi      : object
uri      : object
ftp      : object
scp      : object
resolv   : object
