compile s = c_root(parse(s))

enum ast:
  int:
    value int
  str:
    value str
  ref:
    reference str
  op2:
    type str
    op str
    left ast
    right ast
  func:
    type str
    name str
    args [param]
    body ast
  call:
    name str
    args [ast]
  struct:
    params [param]

struct param:
  name str
  type str

struct define:
  name str
  lines [ast]


parse s = [
  define("main" [
    ast.func(
      "str"
      "main"
      []
      ast.op2(
        "str"
        "."
        ast.str("hello go world 1 + 2 = ")
        ast.call("add" [ast.int(1) ast.int(2)])
      )
    )
    ])
  define("add" [
    ast.func(
      "int"
      "add"
      [param("x" "int") param("y" "int")]
      ast.op2("int" "+" ast.ref("x") ast.ref("y"))
    )
    ])
  ]

c_root defines =
  c_ast x =
  | ast.int = x.value.str
  | ast.str = `"` . x.value . `"`
  | ast.ref = x.reference
  | ast.op2 = c_ast(x.left) . c_op(x.op) . c_ast(x.right)
  | ast.call = "strconv.Itoa(" .  "v." . x.name . "(" . x.args.map(c_ast).join(", ") . ")" . ")"
  | ast.func = "func (v *vt)" . x.name . "(" . c_args(x.args) . ") " . c_type(x.type) .  " { return " . c_ast(x.body) . "}"
  c_type t =
  | "str" = "string"
  | "int" = "int"
  | "void" = ""
  | _ = c_type(t.type)
  c_args args = args.map(c_arg).join(",")
  c_arg x = x.name . " " . x.type
  c_op op =
  | "." = "+"
  | _ = op
  c_define define = define.lines.map(c_ast).join("\n")
  defines.map(c_define).join("\n")
