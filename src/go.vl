compile s = c_root(parse(s))

enum ast:
  int:
    value int
  str:
    value str
  ref:
    reference str
  op2:
    type str
    op str
    left ast
    right ast
  func:
    type str
    name str
    args [param]
    body ast
  call:
    name str
    args [ast]
  struct:
    params [param]

struct param:
  name str
  type str

struct define:
  name str
  lines [ast]


parse s = [
  define("main" [
    ast.func(
      "str"
      "main"
      []
      ast.op2(
        "str"
        "."
        ast.str("hello go world 1 + 2 = ")
        ast.call("add" [ast.int(1) ast.int(2)])
      )
    )
    ])
  define("add" [
    ast.func(
      "int"
      "add"
      [param("x" "int") param("y" "int")]
      ast.op2("int" "+" ast.ref("x") ast.ref("y"))
    )
    ])
  ]

c_root defines =
  c_type t =
  | "str" = "string"
  | "int" = "int"
  | "void" = ""
  | ast.func = c_type(t.type)
  | _ = "BUG"
  c_ast x =
  | ast.int = x.value.str
  | ast.str = `"` . x.value . `"`
  | ast.ref = x.reference
  | ast.op2 = c_op(x.op x.left x.right)
  | ast.call = "v." . x.name . "(" . x.args.map(c_ast).join(", ") . ")"
  | ast.func = "func (v *vt)" . x.name . "(" . c_args(x.args) . ") " . c_type(x.type) .  " { return " . c_ast(x.body) . "}"
  c_args args = args.map(c_arg).join(",")
  c_arg x = x.name . " " . x.type
  c_op op l r =
  | "." _ _ = c_cast(c_type(l) "str" l) . "+" . c_cast(c_type(r) "str" r)
  | "+" _ _ = c_cast(c_type(l) "int" l) . "+" . c_cast(c_type(r) "int" r)
  | _ _ _ = op
  c_cast from to v =
  | "int" "str" _ = "strconv.Itoa(" . c_ast(v) . ")"
  | "int" "int" _ = c_ast(v)
  | _ _ _ = c_ast(v)
  c_define define = define.lines.map(c_ast).join("\n")
  defines.map(c_define).join("\n")

__comment__
| _ = c_type(t.type)
| ast.op2 = c_ast(x.left) . c_op(x.op) . c_ast(x.right)
c_type_of_func name = c_type(defines.filter(x => x.name == name).0.lines.0)
