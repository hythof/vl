import calc parse eval

main = loop repl
repl = do
    src <- get-line
    result <- run src
    put-line result
run src = case parse src
    ng message : message
    ok ast : (case eval ast
        num n         : "$n"
        error message : message)



namespace calc
import system.parser parse as system-parser

AST = num Int
    | op2 String AST AST
    | error String
parse Stream AST
eval AST AST

parer s = case system-parser s top
    ok ast     : ast
    ng message : error message
top = exp `or` value `or` error "miss match"
exp = do
    l <- num
    o <- one-of "+-"
    r <- num
    op2 o l r
value = do
    v <- one-of [0..9] .many
    num v.int
eval (num n) = num n
eval (op2 "+" l r) = op (+) l.eval r.eval
eval (op2 "-" l r) = op (-) l.eval r.eval
op _ (error s) _ = error s
op _ _ (error s) = error s
op f l r = f l r


namespace system

Reader {
    get-bytes Int [Byte]
}


namespace system.parser

Parsing a
return # 定数       constnt
bind   # 入れ子     nesting
map    # 変換       convert
>>     # 破棄合成   discard
<|>    # 選択       option
many   # 繰り返し   loop
sep    # 区切り分割 split
run    # 実行       run

Parsing a = Reader -> ok a | ng String
parse a = Parsing a
one-of [a] (Parsing a)
many (Parsing a) (Parsing [a])
many1 (Parsing a) (Parsing [a])
or (Parsing a) (Parsing a) (Parsing a)

one-of xs = satisfy xs.has
many f = do
many_r f = satisfy
many1 f = do
    x <- f
    xs <- many f
    x:xs
satisfy f = do
    x <- try-get-char
    if f x
        ok x
        ng "$f"


namespace tmp

# example of lazy input and lazy output

Reader s m t {
    read s (m (Maybe (t, s)))
}

# without exception handling
main = do
    convert stdin stdout

# exception handling
main = do
    convert stdin stdout `catch` handle

handle e = case e.caller
    stdin  = print "error stdin $e"
    stdout = print "error stdout $e"
    _      = print "error $e"

# pure
convert Reader -> Writer -> Boolean
convert in out = do
    char <- in.char
    out.char char.upcase
    true
