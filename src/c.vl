main = eval parse("1 + 2")

parse src = ast.op2("+" ast.int(1) ast.int(2))

eval_op2 "+" l r = l + r
eval_op2 "-" l r = l - r
eval (ast.int n) = n
eval (ast.op2 o) =
  l = eval o.left
  r = eval o.right
  eval_op2 o.op l r

enum ast:
# value
  char char
  string string
  int int
  real double
  bool bool
# container
  tuple [ast]
  list [ast]
  map [(string, ast)]
  struct [(string, ast)]
# expression
  func [([arg], ast)]
  ref string
  op2:
    op string
    left ast
    right ast
  apply:
    target ast
    args [ast]
  stmt [line]
# enum
  enum string ast
# void
  void
# runtime only
  error string
  closure [(string, ast)] ast

enum arg:
  ref string
  type:
    name string
    capture string
  match ast
  opt:
    name string
    default ast

type input:
  src string
  pos int

type parser a:
  parse : input => maybe(a, input)

flow parser:
  return a = parser input => just (a, input)
  bind ma mf = parser input =>
    ret <= ma.parse input
    mf ret

satisfy : (char => bool) parser.char
satisfy f = parser (src: pos:) =>
  guard src.size < pos
  c = src pos
  guard f c
  just (c, input(src pos + 1))

one_of xs = satisfy xs.have?
many1 f =
  x = f
  xs = many f
  x : xs
many f = many_acc f []
many_acc f acc = parser input =>
  f(input).if (x => acc : x) acc
