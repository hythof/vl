-- GTD -----------------------------------------
Inbox
- Data Oriented Design, 列毎に配列化してキャッシュヒット率を上げる

NotToDo
- 継承
- 後方参照

Action
- Haskell interpriter
| モナドの設計
| モナドの実装
| Consoleモナドの設計と実装
| ログ設計
  Aspect志向

- vl parser
| 代数データ型
   AST = Int Int
     | String String
     | Array [AST]
     | None
   show AST String
   show x = switch x
     Int v    : v.string
     String v : v
     Array xs : xs.map(show).join(",")
| クラス
  組み込み型: Num, Int, Int8-64, Uint8-64, Float, Float32-64, Char, String, Array, Struct
  宣言: Vector2
          x Int
          y Int
  組み込み機能:
    pos = Vector2 10 20 # {x 10, y 20}
    pos.Type            # == Vector2
    Vector2.fields.0    # {name "x", type Int}
| AST実装
| 型クラス
| 名前空間
| 多倍長数値
| 型宣言
| 型推論
| 型変数
| 文字列展開式 "$name $array.length $(add 1 2)"
| 範囲初期化配列 [1..5] -> [1 2 3 4 5] や ['a' .. 'z']
| 範囲演算子の導入 0 < x < 10
- vl to C
| IO全体の設計と実装(ブロッキングAPIはtimeoutを持つ)
| Consoleモナド
| gracefull shutdown
- vl interpriter
| REPL shell
- ライブラリ実装
| Fileモナド
| Networkモナド
| Taskモナド
| build, release, execution

Project
- 標準ライブラリ実装
- Mac対応
- Windows対応
- コンパイル高速化
- hot deploy対応
- dockerコンテナ化
- vim支援
- emacs支援
- netbeans支援
- プロジェクトの雛形作成
- 多倍長(GnuMP)
- 有理数
- 他言語トランスレーター

Done
- 分岐の構文設計
  if (A==A') B C
  switch A
   A'  : B
   A'' : C
   _   : D
- 分岐の解析テストケース追加
- 分岐の解析実装


-- Design --------------------------------------
方針
- 覚える事が少ない
- 直感に沿う
- 実行時の振る舞いを正確に見て取れる
- 最小実装のみ提供
- 型システム、ライブラリ、モナド、IOは最小実装の上に構築

設計
[x] 言語コンバータ(まずはc)
[x] 値は不変(モナドは例外)
[x] 予約後なし(記号のみ)
[x] IOなし、共通インターフェース用意(Console, File, Network, Date, Random)
[x] 先行評価、遅延評価は@をつける v @(1/1) や @f cond left right = cond ? left : right
[x] 基本型
    - Int      : int64  # Int8, Int16, Int32, Int64, Uint8, Uint16, Uint32, Uint64
    - Real     : double # Real32, Real64
    - Bool     : unsigned char
    - String   : struct { size_t length; char* null_terminate; }
    - Array[]  : &struct { size_t count; size_t capacity; TYPE[] array; }
    - Struct{} : &struct { ... }
    - Function : *void
    - Type     : struct { Field[] fields; Method[] methods; }
[x] 順次  : 関数適用順      : f3 f2 f1
[x] 反復  : 再帰(recursion) : f [] = 0; f [x xs] = x + f xs
[x] 分岐  : ガード          : f x = "number"
                              | x == 0 = "zero"
                              | x > 100 = "big" 
[x] 型宣言  : add Int Int Int
[x] 型定義1 : T1 { x Int; y Int }
[x] 型定義2 : T1 { x 0; y 0 }
[x] 型定義3 : T1 Int Int # パターンマッチでアクセス
[x] 型変数  : List a = [a]
[x] 代数型  : Algebraic = A | B | C
[x] 再起型  : Tree x = Node (Tree x) (Tree x) | Leaf x
[x] 再起代数型 : Calc = BinOp String Value Value
                      | Value (VInt | VReal)
                      | VInt Int
                      | VReal Real
[x] パターンマッチ : f (Int a) = "int"; f (Real a) = "real"
[x] フォルダ階層が名前空間 : .current ..one-up ...two-up
[x] vcsをsubmoduleとして管理、app.yamlに依存関係を書く
[x] 実行レベルを分割
    lv1: haskell runtime
    lv2: 共通API(console, file, network, date, random)
    lv3: 副作用なし(モナドっぽい仕組みでメモリ更新あり)
[] 帯域脱出
[] 例外
[] メモリ更新

最小実装(Haskell)
[x] インタプリタ
[x] lv3: 基本型
[x] lv3: 演算
[x] lv3: 関数定義
[] lv3: 代数データ型

標準実装(vl)
[] lv1: c runtime
[] lv1 + lv2: API設計(console, file, network, date, random, try/catch, call/cc)
[] lv2: メモリ更新
[] lv2: 大域脱出
[] コンパイラ(C言語へ変換しgcc)
[] 型推論
[] 型変数
[] 型クラス
[] モナド
[] インポートと名前空間
[] 文字列展開式の導入 "$name $array.length $(add 1 2)"
[] 範囲初期化配列の導入 [1..5] -> [1 2 3 4 5] や ['a' .. 'z']
[] 範囲演算子の導入 0 < x < 10 < y < 100
[] ユーザ定義演算子(:)の導入 1 :/ 2 で Rational 1 2など
[] ユーザ定義数値(100s)などの導入 100sで Millsecond 100_000、100msで Millsecond 100 など
[] 基本型のメソッド 整数、実数、文字列、真偽値、配列、構造体、関数

標準ライブラリ実装
[] Readline
[] OnMemoryRuntime          # file, network, date, randomを操作できる
[] TCP      (Server/Client) # Protocolとくっつけて使う
[] UDP      (Server/Client) # 同上
[] HTTP/1.1 (Protocol)
[] HTTP/2   (Protocol)
[] MQTT     (Protocol)
[] SMTP     (Protocol)
[] POP3     (Protocol)
[] IMAP4    (Protocol)
[] Radius   (Protocol)

お仕事
[] 開発支援ツール向けフレームワーク
[] テストフレームワーク
[] Deployフレームワーク
[] プロジェクトの雛形作成
[] vim支援
[] emacs支援
[] netbeans支援
[] 多倍長(GnuMP)
[] 有理数

お遊び
[] Pythonへ変換
[] Rubyへ変換
[] Perlへ変換
[] Javascriptへ変換
[] Luaへ変換
[] C#へ変換
[] Swiftへ変換
[] Object-Cへ変換
[] Javaへ変換
[] Haskellへ変換
[] Ocamlへ変換
[] x64実行ファイルへ変換(AMD64 & Intel 64)

-- compile --------------------------------------
-- calc
    eval String Real
    (expr term factor) [String] Real
    eval src = expr (words src)
    expr (x "+" xs) = x + (term xs)
    expr (x "-" xs) = x - (term xs)
    expr xs         = term xs
    term (x "*" xs) = x * (factor xs)
    term (x "/" xs) = x / (factor xs)
    term xs         = factor xs
    factor ("(" xs ")") = expr xs
    factor (x _)    = real x

-- porker
    Elem = enum Spade Dia Clover Heart
    Num = bounds 1..13
    Card = struct Elem Num
    Hands = enum StraightFlush Flush FullHouse Straight FiveCard ForCard ThreeCard TwoPair OnePair Nothing
    Cards = set Card Card Card Card Card
    hands Cards Hands
    hands (e n, e n+1, e n+2, e n+3, e n+4) = StraightFlush
    hands (_ n, _ n+1, Card _ n+2, Card _ n+3, Card _ n+4) = Straight
    hands (e _, e _, e _, e _, e _) = Flush
    hands (_ n, _ n, _ n, _ m, _ m) = FullHouse
    hands (_ n, _ n, _ n, _ n, _ n) = FiveCard
    hands (_ n, _ n, _ n, _ n, _ _) = ForCard
    hands (_ n, _ n, _ n, _ _, _ _) = ThreeCard
    hands (_ n, _ n, _ m, _ m, _ _) = TwoPair
    hands (_ n, _ n, _ _, _ _, _ _) = OnePair
    hands _                         = Nothing

-- language parser
    AST = enum
        Int Int
        Op String AST AST
        Error String

    eval AST AST
    eval (Op op left right) = v l r
        l = eval left
        r = eval right
        v = case l r
            (Error) _ = l
            _ (Error) = r
            (Int lv) (Int rv)  = case op
                "+" = Int $ lv + rv
                "-" = Int $ lv - rv
    eval v = v

    parse String AST
    parse src = top do
        pos 0 -- modifiable

        top = int | op | error
        int = Int $ int $ fill num
        op = Op $ operator top top
            operator = one "+-"
        error = Error "parse error $src[pos:]..."
        num = fill1 ('0' <= _1 <= '9')
        char x = read (== x)
        one [x xs] = fill x | one xs
        fill f = f current ? eat + fill f : ""
        fill1 f = f current ? eat + fill f : throw
        current = src[pos]
        eat = src[pos++]
        | left right = try left catch right

-- outline --------------------------------------
0. target
1. syntax
2. bootstrap
3. library
4. runtime


target
======
- Fun programming and enjoy hacking
- Hate other


syntax
======
count 10
add a b = a + b
qsort [p xs] = qsort lt + [p] + qsort gteq
    lt = xs.filter :< p
    gteq = ys.filter :>= p

Person {
    name ""
    age 0
    greet msg = "$msg $name($age)"
    show = "Person ${greet 'hello'}"
}

p = Person { name "foo" age 31 }
p = Person "foo" 31
p.show

class Person {
    name = ""
    age = 0
}

console: Console port
    print "run echo server on $port"
    daemon port

daemon port: Process
    spawn echo_server
    echo_server: Process.Server port -> socket
        buf = Buffer socket
        buf.readlines buf.puts

main = if argv.empty
          daemon 8080
          console


bootstrap
=========
- ghc
- parser: Parsec3
- repl: pure haskell


library
=======
[text]
json
encode / decode
- ascii, utf8, utf16, utf32, sjis
- base64
- zip, gzip, tar, lzh
hash
- md5
- sha256

[image]
gif
jpeg
png

[net]
ftp (client server)
http (client server)
smtp (client server)
pop3 (client server)
imap4 (client server)
openssl

[num]
math


runtime
=======
- vl to c++ converter
- gc: RAII + Reference Count


memo
====
T1..T99 # Type template
Object {
    + - &
    fields  Table String Object
    methods Table String Object
}
True  1
False 0
Bool  True | False
Nothing {
    | t1 = t1
    & t1 = Nothing
}
Just t1 = t1
Maybe t1 = Nothing | Just t1
Number {
    + - / * ** | &
    < > ==
    byte   Byte
    bytes  Bytes
    string String
}
Size    Number
Integer Number
Double  Number
String {
    +
    < > ==
    raw Bytes
    size Size
    pos    text String = Size
    left   pos Size = String
    right  pos Size = String
    substr pos Size = String
    substr pos Integer size Size = String
    append text String = String
    Regexp {
        pattern String
        match   text String = Maybe String
        replace text String change String = String
        replace text String change(match String = String) = String
        Match Array
    }
    Pattern String | Regexp
    match   pattern String = Bool
    match   pattern Regexp = Maybe Regexp.Match
    replace pattern String change String = String
    replace pattern Regexp change String = String
    replace pattern Regexp change(Regexp.Match = String) = String
    encoding String
    decode encoding = Bytes
}
Array T1 -> T1 {
    + - & | ^
    size = Size
    find check(T1 = Bool ) = Maybe T1
    find check(T1 = Maybe) = Maybe T1
    get   pos Size = Maybe T1
    slice pos Size size Size = Array T1
    table values List  T2 = Table T1 T2
    table values Array T2 = Table T1 T2
}
List T1 -> T2 {
    set    pos Size value T1
    insert pos Integer value T1
    remove pos Size = Bool
    copy   pos Size size Size = List T1
    array = Array T1
}
Table T1 T2 -> T1 T2 {
    + - & | ^
    get key T1 = Maybe T2
    set key T1 value T2
    keys = Array T1
    values = Array T2
}
Byte 0 .. 255
Bytes {
    + & |
    size = Size
    get pos Size = Byte
    set pos Size byte Byte
    copy = Bytes
    copy  pos Size size Size = Bytes
    slice pos Size size Size = Bytes
    encoding String "UTF-8"
    encode encoding = String
}
IO IO.Reader + IO.Writer + {
    timeout Size 0
    Reader {
        read -> buffer Bytes size Size = Result
    }
    Writer {
        write buffer Bytes = Result
    }
    Result Maybe {
        errno Integer
        error String
        is_timeout Bool
    }
}
File {
    path String
    filename path = String
    dirname  path = String
    extname  path = String
    stat path -> {
        uid   Size
        gid   Size
        size  Size
        atime Time
        mtime Time
        ctime Time
        mode  Size 0..0777
        is_dir    Bool
        is_file   Bool
        is_link   Bool
        is_fifo   Bool
        is_socket Bool
    } IO.Result
    chmod   path mode Size 0..0777 = IO.Result
    unlink  path = IO.Result
    mkdir   path = IO.Result
    touch   path = IO.Result
    exists  path = Bool
    list    path = Array File
    read    path -> IO.Reader = IO.Result
    write   path -> IO.Writer = IO.Result
    append  path -> IO.writer = IO.Result
    open    path mode -> IO + {
        size = Size
        pos  = Size
        seek_head
        seek_next pos Size = IO.Result
        seek_end
        is_eof Bool
    } = IO.Result {
        mode "r" | "w" | "a" | "rw"
    }
}
Net {
    host String
    port String
    connect host port -> IO = IO.Result
    listen  host port -> IO = IO.Result
    listen  port -> IO = IO.Result
}
Task {
    mode "thread" | "process"
    Control {
        wait
        down
        is_run
        is_down
    }
    run -> io IO = Control
    wait_all
    down_all
}
Env {
    tz String ""
    now Time
    Time {
        serial Size
        sec    Size 0..60
        min    Size 0..60
        hour   Size 0..24
        day    Size 1..31
        mon    Size 1..12
        year   Size 0..2**32
        wday   Size 0..6
        yday   Size 1..365
        is_dst Bool
        format String "%Y/%m/%d %H:%M:%S"
        strftime format = stringfy:string
    }
    Date Time & {
        serial Size
        day    Size 1..31
        mon    Size 1..12
        year   Size 0..2**32
        wday   Size 0..6
        yday   Size 1..365
        is_dst Bool
        format String "%Y/%m/%d"
        strftime format = stringfy:string
    }
    call   cmd String -> io IO
    spawn  cmd String -> io IO = Task.Control
    system cmd String = String
    conf T1 default T1 = T1
}
Lib {}
whereis C++ implements LanguageInterface

mysql {
    host "localhost"
    port "3078"
    user "guest"
    pass "guest"
    db   "test"
    Instance {
        fetch   sql String = Array Table String String
        filter  sql String where String = Query
        execute sql 
    }
    connect host port user pass db -> con Instance = Net.connect host port -> sock {
    }
}

# model.vl
mysql Lib,Mysql.Instance
list = mysql.query "SELECT * FROM foo"

# view.vl
list [{name price String}]
table
  tr
    th title
  tr % list -> row
    td row.name
    td row.price

# control.vl
mysql Lib.Mysql.Instance
HttpResponse {
    stringfy = String
}
dispatch path String = HttpResponse {
    mysql.connect -> sql {
        model = Lib.model sql
        view
    }
}


# main.vl
main -> arg flag opt {
    arg Array String
    flag Table String Bool
    opt String String
    Lib.control
}

# file io
main -> files [String] {
    files -> file File {
        next if file.is_exists
        file.open -> fh -> fh.readline -> line {
        } else {
            puts "error"
        }
    }
}

main : files [String] {
    files -> file {
        next if file.is_exists
        file.open -> .readlines -> line {
            puts line
        }
    }
}

main : paths [Strings]
paths = [File x for x in paths if x.is_exists]
for path = paths:
    for line = file.open.readlines:
        puts line



memo
====
fizbuz = (1 .. 100).map > n (
        "FizBuz" ? n / 15 == 0
        "Buzz"   ? n / 5 == 0
        "Fizz"   ? n / 3 == 0
        n
)
file_contents path = File.open path { fh; return fh.read }
file_contents path = File.open path : .read

strftime fmt n = fmt.replace {"%Y"=y + 1970; "%m"=m}
{
    y = n / 60 / 60 / 24 / 365
    _d = n - (y * 60 * 60 * 24 * 365)
    m = 0
    h = 0
    i = 0
    s = a + b + c
}


list = File.glob "**/*.rb"
Array File {
    String {
        show kw = replace kw "** " ++ kw ++ " **"
    }
    search kw = trancelate -> f (
        f.path.include kw -> f.path.show kw
        content.index kw  -> pos; content.line_of_pos(pos).show kw
        content = f.read
    })
}
main arg = list.search arg.0
