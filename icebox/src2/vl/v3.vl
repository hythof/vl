# ---( ast.vl )-----------------------------------------------------
AST Enum
    # value
    Int Int
    Real Real
    String String
    Bool Bool
    List [AST]
    Struct [Define]
    Func [String] AST
    # refelence
    Lookup String [AST]
    # exp
    Op String AST AST
    # selection
    If AST AST AST
    # type
    Type String [Type]
    # syntax error
    Error String

Define Struct
    name String
    ast AST

Type Enum
    TInt
    TReal
    TString
    TBool
    TStruct
    TList Type
    TFunc [Type]
    TClass String

# ---( compile.vl )-----------------------------------------------------
compile [AST] String
compile xs = """
#include <stdlib.h>
$define
int main() {
    return vl_main();
}
"""
    define = "\n".join $ xs.map func
    func (Define name args ast) = """
            int $name($arg_string) {
                return $(exp ast)
            }
        """
        arg_string = "int " + (", int".join args)
        exp AST String
        exp (Op op left right) = v
            l = exp left
            r = exp right
            v = case l r
                (Error e) _ = e
                _ (Error e) = e
                (Int lv) (Int rv) = case op
                    "+" = "$lv + $rv"
                    "-" = "$lv - $rv"
        exp (Int v) = "$v"
        exp (Error s) = s

# ---( eval.vl )-----------------------------------------------------
eval [AST] AST
eval xs = evalution $ xs $ lookup "main" xs

evalution xs x = exp x
    lookup target ((Define name ast) rest) = if name == target then exp ast else lookup rest
    exp (Op op left right) = v l r
        l = eval left
        r = eval right
        v = case l r
            (Error) _ = l
            _ (Error) = r
            (Int lv) (Int rv) = case op
                "+" = Int $ lv + rv
                "-" = Int $ lv - rv
            (Real lv) (Real rv) = case op
                "+" = Real $ lv + rv
                "-" = Real $ lv - rv
            (List lv) (List rv) = case op
                "+" = List $ lv + rv
            _ _ = Error "operate $op $l $r"
    exp (Lookup name args) = evalution (xs + scope) ast
        (Func names ast) = lookup name
        scope = def names values
            def [] _ = []
            def _ [] = []
            def (x xs) (y ys) = Define $ x y + (def xs ys)
    exp x(Int _) = x
    exp x(Real _) = x
    exp x(Error _) = x
    exp x(String _) = x
    exp x(Bool _) = x
    exp (If cond true false) = if exp cond then true else false
    exp x = Error "$x"

# ---( parse.vl )-----------------------------------------------------
parse String [Define]
parse src = lib.parser src do top

lib.parser do
    # start
    top = many define
    # combination
    define = func
           | type
           | field
        func do
            name = id
            string "="
            body = exp
            Define func_name body
        type do
            name = id
            body = many const
            Define name body
        field do
            name = id
            body = exp
            Define name exp
    exp = int
          | real
          | string
          | bool
          | list
          | struct
          | func       
          | lookup
          | op
          | cond
        int    = Int    $ fill isNumber
        real   = Double $ (.real) $ num + (string ".") + num
        string = String $ between (string "\"") (string "\"") any
        bool   = Bool   $ string "T"
        list   = List   $ between "[" "]" $ many exp
        struct = Struct $ between "{" "}" $ many define
        func   = Func   $ name any
        lookup = Lookup $ name $ many exp
        op     = Op     $ op_name exp exp
          op_name = operator [
            "*" 
            "/" 
            "%" 
            "//"
            "<<"
            ">>"
            "=="
            "**"
            "+"
            "-"
            "|"
            "&"
          ]
        cond = do
            string "if"
            cond = exp
            string "then"
            true = exp
            string "else"
            false = exp
            If cond true false
    # utility
    id = many $ one "a" .. "z"
    var = separator id "."
    const = many $ one "A".."Z"

# lib/parser.vl
parser String Do
parser src do
    pos 0
    num = fill1 ('0' <= _1 <= '9')
    char x = read (== x)
    one [x xs] = fill x | one xs
    fill f = f current ? eat + fill f : ""
    fill1 f = f current ? eat + fill f : fail
    current = src[pos]
    eat = src[pos++]
